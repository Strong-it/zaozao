## MyBatis 缓存机制

## Mybatis系统中默认定义来两级缓存（一级缓存和二级缓存）
1. 默认情况下，只有一级缓存(SqlSession级别的缓存，也称为本地缓存)开启
        1. 与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果需要相同数据，直接从缓存中获取，没必要再取查询数据库
2. 二级缓存需要手动开启和配置，基于`namespace`级别的缓存（全局缓存）
3. 为了提高扩展性。Mybatis定义来缓存接口`Cache`。我们可以通过实现`Cache`接口定义二级缓存

## 一级缓存失效的情况（默认一直开启）
1. sqlSession不同
2. sqlSession相同，查询条件不同（当前一级缓存中没有当前数值）
3. sqlSession相同，两次查询之间执行来增删改操作（这次增删改可能对当前数据有影响）
4. sqlSession相同， sqlSession.clearCache()

## 二级缓存：（全局缓存）基于namespace级别的缓存，一个namespace对应一个二级缓存
1. 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中
2. 如果会话关闭，一级缓存中数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存
3. 不同的namespace查出的数据会放在自己对应的缓存中(map)
        1. 查出的数据默认放在一级缓存中，只有会话提交或者关闭以后，一级缓存中的数据才会放到二级缓存中

## 二级缓存的使用策略
1. 全局配置 `<seting name="cacheEnabled" value="true">`
2. 在Mapper.xml文件中使用配置 `<cache></cache>`
        1. `eviction` 缓存的回收策略
            1. `LRU` 最近最少使用，移除最长时间不被使用的对象
            2. `FIFO` 先进先出，按对象进入缓存的顺序来移除它们
            3. `SOFT` 软引用，移除基于垃圾回收器状态和软引用规则的对象
            4. `WEAK` 弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象
            5. 默认是LRU
        2. `flushInterval` 缓存刷新时间间隔。缓存多长时间清空一次，默认部清空，设置一个毫秒值
        3. `readOnly` 缓存是否只读。
            1. `true` mybatis认为所有从缓存中获取的数据操作都是只读，不会修改数据。mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，但速度快
            2. `false` mybatis认为数据可能会修改，mybatis会利用序列化和反序列化的技术克隆一份数据。安全，但速度慢
        4. `size` 缓存存放多少元素
        5. `type` 指定自定义缓存的全类名。实现Cache接口
3. 我们的POJO需要实现序列化接口

## 和缓存有关的设置
1. `cacheEnable=true` false 关闭二级缓存，并不关闭一级缓存
2. 每个`select`标签都有`useCache=false`关闭二级缓存，并不关闭一级缓存
3. 每个增删改标签都有`flushCache=true` 因此执行完之后都会清除缓存，一级缓存清空，二级缓存也会清空。但是会先从二级缓存查询。
4. `sqlSession.clearCache` 只会清除当前Session的一级缓存，不会清空二级缓存
5. `localCacheScope` 本地作用域（一级缓存`SESSION`），当前所有的数据保存在会话缓存中。（`STATEMENT`）可以禁用一级缓存